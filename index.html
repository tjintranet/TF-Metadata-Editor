<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T&F XML Editor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <style>
        .editable-field {
            padding: 5px;
            margin: 2px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .editable-field:focus {
            outline: none;
            border-color: #86b7fe;
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
        }
        .field-label {
            font-weight: bold;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1 class="mb-4">T&F XML Editor</h1>
        <div class="mb-3">
            <input class="form-control" type="file" id="xmlFileInput" accept=".xml" onchange="handleFileUpload()">
        </div>
        <div class="mb-3">
            <button class="btn btn-success me-2" onclick="downloadXML()" id="downloadBtn" style="display: none;">Download XML</button>
            <button class="btn btn-secondary" onclick="clearAll()">Clear</button>
        </div>
        <div id="result" class="mt-4"></div>
    </div>

    <script>
        let originalXmlDoc = null;
        let elementPaths = new Map();
        let originalFileName = '';

        // Define the fields we want to display and edit based on the XSLT
        const editableFields = [
            { path: '//product/production_class', label: 'Production Route' },
            { path: '//product/title', label: 'Title' },
            { path: '//product/isbn', label: 'ISBN' },
            { path: '//product/version_type', label: 'Binding' },
            { path: '//product/page_extent', label: 'Page Extent' },
            { path: '//product/format/width', label: 'Width' },
            { path: '//product/format/height', label: 'Height' },
            { path: '//product/parts/text/spine', label: 'Spine Size' },
            { path: '//product/parts/text/colour', label: 'Text Colour' },
            { path: '//product/parts/text/grammage', label: 'Text Paper GSM' },
            { path: '//product/parts/covers/treatment', label: 'Lamination' }
        ];

        function handleFileUpload() {
            const fileInput = document.getElementById('xmlFileInput');
            const file = fileInput.files[0];
            
            if (file) {
                originalFileName = file.name;
                const reader = new FileReader();
                reader.onload = function(e) {
                    const xmlString = e.target.result;
                    parseXML(xmlString);
                };
                reader.readAsText(file);
            }
        }

        function parseXML(xmlString) {
            const parser = new DOMParser();
            originalXmlDoc = parser.parseFromString(xmlString, "text/xml");
            elementPaths.clear();
            
            displayEditableXML(originalXmlDoc);
            document.getElementById('downloadBtn').style.display = 'inline-block';
        }

        function getElementByXPath(xpath, contextNode) {
            const evaluator = new XPathEvaluator();
            const resolver = evaluator.createNSResolver(contextNode.ownerDocument == null ? 
                contextNode.documentElement : contextNode.ownerDocument.documentElement);
            const result = evaluator.evaluate(xpath, contextNode, resolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
            return result.singleNodeValue;
        }

        function displayEditableXML(xmlDoc) {
            let resultHTML = '<div class="card"><div class="card-body">';
            
            editableFields.forEach(field => {
                const element = getElementByXPath(field.path, xmlDoc);
                if (element) {
                    elementPaths.set(field.path, element);
                    
                    resultHTML += `
                        <div class="mb-3">
                            <label class="field-label">${field.label}</label>
                            <div
                                class="editable-field"
                                contenteditable="true"
                                data-xpath="${field.path}"
                            >${element.textContent}</div>
                        </div>
                    `;
                }
            });
            
            resultHTML += '</div></div>';
            document.getElementById('result').innerHTML = resultHTML;

            // Add event listeners for content changes
            document.querySelectorAll('.editable-field').forEach(field => {
                field.addEventListener('input', function() {
                    const xpath = this.getAttribute('data-xpath');
                    const element = elementPaths.get(xpath);
                    if (element) {
                        element.textContent = this.textContent;
                    }
                });
            });
        }

        function clearAll() {
            document.getElementById('xmlFileInput').value = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('downloadBtn').style.display = 'none';
            originalXmlDoc = null;
            originalFileName = '';
            elementPaths.clear();
        }

        function downloadXML() {
            if (!originalXmlDoc) {
                alert('No XML file loaded');
                return;
            }

            // Create the XML string with proper formatting
            const serializer = new XMLSerializer();
            let xmlString = serializer.serializeToString(originalXmlDoc);
            
            // Add XML declaration if it's missing
            if (!xmlString.startsWith('<?xml')) {
                xmlString = '<?xml version="1.0" encoding="UTF-8"?>\n' + xmlString;
            }

            // Format the XML string
            xmlString = formatXML(xmlString);
            
            // Create and trigger download
            const blob = new Blob([xmlString], { type: 'text/xml' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = originalFileName || 'edited.xml';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function formatXML(xml) {
            let formatted = '';
            let indent = '';
            const tab = '    '; // 4 spaces for indentation
            
            xml.split(/>\s*</).forEach(function(node) {
                if (node.match(/^\/\w/)) {
                    indent = indent.substring(tab.length);
                }
                
                formatted += indent + '<' + node + '>\n';
                
                if (node.match(/^<?\w[^>]*[^\/]$/)) {
                    indent += tab;
                }
            });
            
            return formatted.substring(1, formatted.length - 2);
        }
    </script>
</body>
</html>